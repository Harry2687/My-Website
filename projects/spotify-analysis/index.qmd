---
title: "Analysis of My Spotify Data"
description: "Categorisation of my Spotify listening history using k-means clustering."
categories: [K-means, R]
author:
  - name: Harry Zhong
date: today
date-modified: last-modified
image: kmeans-preview.png
draft: false
---

```{r}
#| include: false
source("scripts/packages.R")
```

# Introduction

The motivation for this project was:

1. I like music.
2. I wanted to learn about clustering.

So, let's get into how we can use R and Spotify's Web API to categorise songs that we have listened to.

# Data Extraction

For this project, there are two key datasets that we need:

1. Listening activity history.
2. Track features.

The first can be obtained by [requesting your Spotify data](https://www.spotify.com/us/account/privacy/){target=_blank}. For this project, we will using the extended streaming history option, which takes longer to process but gives us our full listening history as opposed to only the most recent year.

The second dataset can be generated from our listening activity using Spotify's [Web API](https://developer.spotify.com/documentation/web-api){target=_blank} to pull track features for each song in our streaming history.

## Activity History Data

Our Spotify activity history data is given as a set of `.json` files. We can extract the data from all the `.json` files into a dataframe and perform some preliminary cleaning using the code below.

```{r}
#| code-fold: true
#| code-summary: "Show code"

files <- list.files(
  "data/full_history_data", 
  pattern = "*.json", 
  full.names = TRUE
)

full_streaming_history <- foreach(
  file = files, 
  .packages = c("jsonlite"),
  .combine = rbind
) %do% {
  fromJSON(file, flatten = TRUE)
} %>%
  rename(
    track_name = "master_metadata_track_name",
    artist_name = "master_metadata_album_artist_name"
  ) %>%
  mutate(
    track_uri = gsub(
      "spotify:track:", 
      "", 
      spotify_track_uri
    ),
    month = ts %>%
      substring(1, 7) %>%
      paste0("-01") %>%
      ymd()
  ) %>%
  select(
    -spotify_track_uri,
    -username,
    -platform,
    -ip_addr_decrypted
  ) %>%
  filter(month >= ymd("2019-04-01"))
```

```{r}
full_streaming_history %>%
  head() %>%
  kable()
```

From here, we can use the `ggplot2` and `shiny` packages to visualise trends in my most listened to artists and tracks.

```{=html}
<iframe src="https://harryz.shinyapps.io/spotify_data_dashboard/" style="border: none; width: 100%; height: 620px"></iframe>
```

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "app.R"

library(shiny)
library(tidyverse)
library(here)
library(foreach)

files <- list.files(
  paste0(here(), "/data/full_history_data"), 
  pattern = "*.json", 
  full.names = TRUE
)

full_streaming_history <- foreach(
  file = files, 
  .packages = c("jsonlite"),
  .combine = rbind
) %do% {
  fromJSON(file, flatten = TRUE)
} %>%
  rename(
    track_name = "master_metadata_track_name",
    artist_name = "master_metadata_album_artist_name"
  ) %>%
  mutate(
    track_uri = gsub("spotify:track:", "", spotify_track_uri),
    month = ts %>%
      substring(1, 7) %>%
      paste0("-01") %>%
      ymd()
  ) %>%
  select(-spotify_track_uri) %>%
  filter(month >= ymd("2019-04-01"))

min_date <- full_streaming_history %>%
  pull(month) %>%
  min()

max_date <- full_streaming_history %>%
  pull(month) %>%
  max()

ui <- fluidPage(
  titlePanel("Spotify Streaming History"),
  sidebarLayout(
    sidebarPanel(
      sliderInput(
        "top_n_artists",
        "Top n Artists",
        min = 1,
        max = 20,
        value = 10
      ),
      sliderInput(
        "top_n_tracks",
        "Top n Tracks",
        min = 1,
        max = 20,
        value = 10
      ),
      sliderInput(
        "dates",
        "Streaming History Date Range",
        min = min_date,
        max = max_date,
        value = c(max_date %m-% months(6), max_date)
      )
    ),
    mainPanel(
      tabsetPanel(
        type = "tabs",
        tabPanel(
          "Artist History Plot", 
          h2(textOutput("artist_history_title")),
          plotOutput("artist_history_plot")
        ),
        tabPanel(
          "Track History Plot",
          h2(textOutput("track_history_title")),
          plotOutput("track_history_plot")
        )
      )
    )
  )
)

server <- function(input, output) {
  output$artist_history_title <- renderText({
    top_n_artists <- input$top_n_artists
    
    paste0(
      "Proportion of Hours Listened: Top ",
      top_n_artists,
      " Artists"
    )
  })
  
  output$artist_history_plot <- renderPlot({
    top_artists <- data.frame(
      month = full_streaming_history %>%
        select(month) %>%
        distinct()
    ) %>%
      mutate(
        top_artists = map(
          month,
          ~full_streaming_history %>%
            filter(month == .x) %>%
            group_by(artist_name) %>%
            summarise(time = sum(ms_played)) %>%
            slice_max(time, n = as.numeric(input$top_n_artists)) %>%
            pull(artist_name)
        )
      )
    
    artist_summary <- full_streaming_history %>%
      filter(
        month %>%
          between(input$dates[1], input$dates[2])
      ) %>%
      left_join(
        top_artists,
        by = "month"
      ) %>%
      rowwise() %>%
      filter(artist_name %in% top_artists) %>%
      group_by(
        artist_name, 
        month
      ) %>%
      summarise(hours_listened = sum(ms_played/(1000*60)))
    
    ggplot(artist_summary, aes(x = month, y = hours_listened, fill = artist_name, label = artist_name)) +
      xlab("Date") +
      ylab("Proportion") +
      geom_bar(position = "fill", stat = "identity") +
      geom_text(size = 3, position = position_fill(vjust = 0.5)) +
      theme(legend.position = "none")
  })
  
  output$track_history_title <- renderText({
    top_n_tracks <- input$top_n_tracks
    
    paste0(
      "Proportion of Hours Listened: Top ",
      top_n_tracks,
      " Tracks"
    )
  })
  
  output$track_history_plot <- renderPlot({
    top_tracks <- data.frame(
      month = full_streaming_history %>%
        select(month) %>%
        distinct()
    ) %>%
      mutate(
        top_tracks = map(
          month,
          ~full_streaming_history %>%
            filter(month == .x) %>%
            mutate(track_artist_name = paste(track_name, artist_name, sep = "\n")) %>%
            group_by(track_artist_name) %>%
            summarise(time = sum(ms_played)) %>%
            slice_max(time, n = as.numeric(input$top_n_tracks)) %>%
            pull(track_artist_name)
        )
      )
    
    track_summary <- full_streaming_history %>%
      filter(
        month %>%
          between(input$dates[1], input$dates[2])
      ) %>%
      mutate(track_artist_name = paste(track_name, artist_name, sep = "\n")) %>%
      left_join(
        top_tracks,
        by = "month"
      ) %>%
      rowwise() %>%
      filter(track_artist_name %in% top_tracks) %>%
      group_by(
        track_artist_name, 
        month
      ) %>%
      summarise(hours_listened = sum(ms_played/(1000*60)))
    
    ggplot(track_summary, aes(x = month, y = hours_listened, fill = track_artist_name, label = track_artist_name)) +
      xlab("Date") +
      ylab("Proportion") +
      geom_bar(position = "fill", stat = "identity") +
      geom_text(size = 3, position = position_fill(vjust = 0.5)) +
      theme(legend.position = "none")
  })
}

shinyApp(ui = ui, server = server)
```


## Track Feature Data

Next, we'll need to use Spotify's Web API to obtain track features, which requires the track ID of each track we're interested in. Fortunately, since we requested our full activity history, this data is included as a column. 

We can use the `httr` and `jsonlite` packages to create a function that takes a Spotify track ID and returns its track features.

```{r}
get_audio_features <- function(track_id) {
  url = paste0("https://api.spotify.com/v1/audio-features/", track_id)
  response <- GET(
    url,
    add_headers(Authorization = paste("Bearer", spotify_token))
  )
  data <- fromJSON(
    content(
      response, 
      "text", 
      encoding = "UTF-8"
    )
  )
  return(data)
}
```

Given the large number of track IDs, using this function on all tracks in our dataset is a long and painful process, where we will get rate limited many times by Spotify. Conveniently, I have a local file containing all of our tracks and their associated track features, which I will load in.

The description for each feature can be found in Spotify's [documentation](https://developer.spotify.com/documentation/web-api/reference/get-audio-features){target=_blank}.

```{r}
#| output: false

full_track_features <- read_csv("data/feature_data/full_track_features.csv")
```

```{r}
full_track_features %>%
  head() %>%
  kable()
```

We can then remove discrete track features and scale the remaining features so that the clusters are not affected by the difference in magnitude of different features.

```{r}
feature_matrix <- full_track_features %>%
  mutate(track_artist = paste(track_name, artist_name, sep = " - ")) %>%
  select(
    -track_name, 
    -artist_name
  ) %>%
  column_to_rownames(var = "track_artist") %>%
  select(
    -track_uri,
    -key,
    -mode,
    -time_signature
  ) %>%
  scale()
```

```{r}
feature_matrix %>%
  head() %>%
  kable()
```

# K-means

Now that we have the required data, we can move on to the machine learning algorithm of interest, k-means clustering.

## What is K-means?

## Feature selection



```{r}
#| code-fold: true
#| code-summary: "Show code"

kmeans_select_features <- function(n, data, nstart, itermax) {
  comb_n <- data %>%
    colnames() %>%
    combn(n, simplify = FALSE)
  
  old_cols <- seq(1, n)
  new_cols <- paste0("factor_", seq(1, n))
  
  new_cols_sym <- syms(new_cols)
  
  factor_combinations_n <- do.call(rbind.data.frame, comb_n) %>%
    rename_with(~new_cols, all_of(old_cols)) %>%
    mutate(factors = pmap(list(!!!new_cols_sym), c)) %>%
    mutate(n_factors = n) %>%
    select(-(!!new_cols)) %>%
    mutate(data = map(factors,
                      ~data %>%
                        as.data.frame() %>%
                        select(all_of(.x)))) %>%
    mutate(n_clusters = map(data,
                            ~fviz_nbclust(.x, 
                                          kmeans, 
                                          nstart = nstart, 
                                          iter.max = itermax)[["data"]] %>%
                              slice(which.max(y)) %>%
                              select(clusters) %>%
                              as.numeric(),
                            .progress = paste("Finding optimal n_clusters:", 
                                              n, 
                                              "factors")) %>%
             as.numeric()) %>% 
    mutate(km = map2(data,
                     n_clusters,
                     ~kmeans(.x, 
                             .y, 
                             nstart = nstart, 
                             iter.max = itermax,
                             algorithm = "MacQueen"),
                     .progress = paste("Calculating kmeans:", 
                                       n, 
                                       "factors"))) %>%
    mutate(total_withinss = map(km,
                                ~.x$tot.withinss) %>%
             as.numeric(),
           bsstssRatio = map(km,
                             ~.x$betweenss/.x$totss) %>%
             as.numeric()) %>%
    mutate(km_plot = map2(km,
                          data,
                          ~fviz_cluster(.x,
                                        data = .y,
                                        geom = "point",
                                        ellipse.type = "convex"))) %>%
    arrange(desc(bsstssRatio))  
  
  return(factor_combinations_n)
}
```

```{r}
#| eval: false

set.seed(2687)

cl <- makeCluster(detectCores())
registerDoParallel(cl)

kmeans_nfact <- foreach(n = seq(2, ncol(feature_matrix)),
                        .packages = c(
                          "tidyverse",
                          "cluster",
                          "factoextra",
                          "rlang"
                        ),
                        .combine = bind_rows) %dopar% {
                          kmeans_select_features(n, feature_matrix, 25, 1000)
                        } %>% 
  arrange(desc(bsstssRatio))

stopCluster(cl)
```

```{r}
load("data/R_data/kmeans_nfact.RData")
```

```{=html}
<iframe src="https://harryz.shinyapps.io/spotify_clustering_dashboard/" style="border: none; width: 100%; height: 900px"></iframe>
```

# Results



```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/playlist/3z6wsrB2nCHxq0ZHv7slpo?utm_source=generator" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>
```