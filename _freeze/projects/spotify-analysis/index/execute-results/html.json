{
  "hash": "fc8a2aebe61e93f24742fb74d14d104c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Analysis of My Spotify Data\"\ndescription: \"Categorisation of my Spotify listening history using k-means clustering.\"\ncategories: [K-means, R]\nauthor:\n  name: Harry Zhong\ndate: 2024-03-23\nimage: kmeans-preview.png\n---\n\n\n\n\n# Introduction\n\nThe motivation for this project was:\n\n1. I thought it would be fun.\n2. That's it.\n\nSo, let's get into how we can use R and Spotify's Web API to categorise songs that we have listened to.\n\n# Data Extraction\n\nFor this project, there are two key datasets that we need:\n\n1. Listening activity history.\n2. Track features.\n\nThe first can be obtained by [requesting your Spotify data](https://www.spotify.com/us/account/privacy/){target=_blank}. For this project, we will using the extended streaming history option, which takes longer to process but gives us our full listening history as opposed to only the most recent year.\n\nThe second dataset can be generated from our listening activity using Spotify's [Web API](https://developer.spotify.com/documentation/web-api){target=_blank} to pull track features for each song in our streaming history.\n\n## Activity History Data\n\nOur Spotify activity history data is given as a set of `.json` files. We can extract the data from all the `.json` files into a dataframe and perform some preliminary cleaning using the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Activity History Code\"}\nfiles <- list.files(\n  \"data/full_history_data\", \n  pattern = \"*.json\", \n  full.names = TRUE\n)\n\nfull_streaming_history <- foreach(\n  file = files, \n  .packages = c(\"jsonlite\"),\n  .combine = rbind\n) %do% {\n  fromJSON(file, flatten = TRUE)\n} %>%\n  rename(\n    track_name = \"master_metadata_track_name\",\n    artist_name = \"master_metadata_album_artist_name\"\n  ) %>%\n  mutate(\n    track_uri = gsub(\n      \"spotify:track:\", \n      \"\", \n      spotify_track_uri\n    ),\n    month = ts %>%\n      substring(1, 7) %>%\n      paste0(\"-01\") %>%\n      ymd()\n  ) %>%\n  select(\n    -spotify_track_uri,\n    -username,\n    -platform,\n    -ip_addr_decrypted\n  ) %>%\n  filter(month >= ymd(\"2019-04-01\"))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|ts                   | ms_played|conn_country |user_agent_decrypted |track_name               |artist_name     |master_metadata_album_album_name |episode_name |episode_show_name |spotify_episode_uri |reason_start |reason_end |shuffle |skipped |offline | offline_timestamp|incognito_mode |track_uri              |month      |\n|:--------------------|---------:|:------------|:--------------------|:------------------------|:---------------|:--------------------------------|:------------|:-----------------|:-------------------|:------------|:----------|:-------|:-------|:-------|-----------------:|:--------------|:----------------------|:----------|\n|2024-02-08T23:57:04Z |      2072|AU           |unknown              |Kiss Me More (feat. SZA) |Doja Cat        |Planet Her                       |NA           |NA                |NA                  |trackdone    |fwdbtn     |FALSE   |TRUE    |FALSE   |        1707436622|FALSE          |3DarAbFujv6eYNliUTyqtz |2024-02-01 |\n|2024-02-08T23:57:01Z |    219724|AU           |unknown              |vampire                  |Olivia Rodrigo  |GUTS                             |NA           |NA                |NA                  |fwdbtn       |trackdone  |FALSE   |FALSE   |FALSE   |        1707436403|FALSE          |1kuGVB7EU95pJObxwvfwKS |2024-02-01 |\n|2024-02-08T23:53:23Z |      2284|AU           |unknown              |Judas                    |Lady Gaga       |Born This Way                    |NA           |NA                |NA                  |fwdbtn       |fwdbtn     |FALSE   |TRUE    |FALSE   |        1707436400|FALSE          |7F25roCtYi55JouckaayPC |2024-02-01 |\n|2024-02-08T23:53:20Z |      1721|AU           |unknown              |Heads Will Roll          |Yeah Yeah Yeahs |It's Blitz!                      |NA           |NA                |NA                  |fwdbtn       |fwdbtn     |FALSE   |TRUE    |FALSE   |        1707436398|FALSE          |2WRFD9WczJ975X2K1Y9YVs |2024-02-01 |\n|2024-02-08T23:53:18Z |      4018|AU           |unknown              |What You Waiting For?    |Gwen Stefani    |Love Angel Music Baby            |NA           |NA                |NA                  |fwdbtn       |fwdbtn     |FALSE   |TRUE    |FALSE   |        1707436394|FALSE          |0ny5zITdmyNwyTPVzRGscU |2024-02-01 |\n|2024-02-08T23:53:14Z |      2404|AU           |unknown              |Space Song               |Beach House     |Depression Cherry                |NA           |NA                |NA                  |fwdbtn       |fwdbtn     |FALSE   |TRUE    |FALSE   |        1707436392|FALSE          |3CLhX1JkJZ4s5umNnOqCRh |2024-02-01 |\n\n\n:::\n:::\n\n\nFrom here, we can use the `ggplot2` and `shiny` packages to visualise trends in my most listened to artists and tracks.\n\n\n```{=html}\n<iframe src=\"https://harryz.shinyapps.io/spotify_data_dashboard/\" style=\"border: none; width: 100%; height: 620px\"></iframe>\n```\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"app.R\"}\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(here)\nlibrary(foreach)\n\nfiles <- list.files(\n  paste0(here(), \"/data/full_history_data\"), \n  pattern = \"*.json\", \n  full.names = TRUE\n)\n\nfull_streaming_history <- foreach(\n  file = files, \n  .packages = c(\"jsonlite\"),\n  .combine = rbind\n) %do% {\n  fromJSON(file, flatten = TRUE)\n} %>%\n  rename(\n    track_name = \"master_metadata_track_name\",\n    artist_name = \"master_metadata_album_artist_name\"\n  ) %>%\n  mutate(\n    track_uri = gsub(\"spotify:track:\", \"\", spotify_track_uri),\n    month = ts %>%\n      substring(1, 7) %>%\n      paste0(\"-01\") %>%\n      ymd()\n  ) %>%\n  select(-spotify_track_uri) %>%\n  filter(month >= ymd(\"2019-04-01\"))\n\nmin_date <- full_streaming_history %>%\n  pull(month) %>%\n  min()\n\nmax_date <- full_streaming_history %>%\n  pull(month) %>%\n  max()\n\nui <- fluidPage(\n  titlePanel(\"Spotify Streaming History\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\n        \"top_n\",\n        \"Top n\",\n        min = 1,\n        max = 20,\n        value = 10\n      ),\n      sliderInput(\n        \"dates\",\n        \"Streaming History Date Range\",\n        min = min_date,\n        max = max_date,\n        value = c(max_date %m-% months(6), max_date)\n      )\n    ),\n    mainPanel(\n      tabsetPanel(\n        type = \"tabs\",\n        tabPanel(\n          \"Artist History Plot\", \n          h2(textOutput(\"artist_history_title\")),\n          plotOutput(\"artist_history_plot\")\n        ),\n        tabPanel(\n          \"Track History Plot\",\n          h2(textOutput(\"track_history_title\")),\n          plotOutput(\"track_history_plot\")\n        )\n      )\n    )\n  )\n)\n\nserver <- function(input, output) {\n  output$artist_history_title <- renderText({\n    top_n <- input$top_n\n    \n    paste0(\n      \"Proportion of Hours Listened: Top \",\n      top_n,\n      \" Artists\"\n    )\n  })\n  \n  output$artist_history_plot <- renderPlot({\n    top_artists <- data.frame(\n      month = full_streaming_history %>%\n        select(month) %>%\n        distinct()\n    ) %>%\n      mutate(\n        top_artists = map(\n          month,\n          ~full_streaming_history %>%\n            filter(month == .x) %>%\n            group_by(artist_name) %>%\n            summarise(time = sum(ms_played)) %>%\n            slice_max(time, n = as.numeric(input$top_n)) %>%\n            pull(artist_name)\n        )\n      )\n    \n    artist_summary <- full_streaming_history %>%\n      filter(\n        month %>%\n          between(input$dates[1], input$dates[2])\n      ) %>%\n      left_join(\n        top_artists,\n        by = \"month\"\n      ) %>%\n      rowwise() %>%\n      filter(artist_name %in% top_artists) %>%\n      group_by(\n        artist_name, \n        month\n      ) %>%\n      summarise(hours_listened = sum(ms_played/(1000*60)))\n    \n    ggplot(artist_summary, aes(x = month, y = hours_listened, fill = artist_name, label = artist_name)) +\n      xlab(\"Date\") +\n      ylab(\"Proportion\") +\n      geom_bar(position = \"fill\", stat = \"identity\") +\n      geom_text(size = 3, position = position_fill(vjust = 0.5)) +\n      theme(legend.position = \"none\")\n  })\n  \n  output$track_history_title <- renderText({\n    top_n <- input$top_n\n    \n    paste0(\n      \"Proportion of Hours Listened: Top \",\n      top_n,\n      \" Tracks\"\n    )\n  })\n  \n  output$track_history_plot <- renderPlot({\n    top_tracks <- data.frame(\n      month = full_streaming_history %>%\n        select(month) %>%\n        distinct()\n    ) %>%\n      mutate(\n        top_tracks = map(\n          month,\n          ~full_streaming_history %>%\n            filter(month == .x) %>%\n            mutate(track_artist_name = paste(track_name, artist_name, sep = \"\\n\")) %>%\n            group_by(track_artist_name) %>%\n            summarise(time = sum(ms_played)) %>%\n            slice_max(time, n = as.numeric(input$top_n)) %>%\n            pull(track_artist_name)\n        )\n      )\n    \n    track_summary <- full_streaming_history %>%\n      filter(\n        month %>%\n          between(input$dates[1], input$dates[2])\n      ) %>%\n      mutate(track_artist_name = paste(track_name, artist_name, sep = \"\\n\")) %>%\n      left_join(\n        top_tracks,\n        by = \"month\"\n      ) %>%\n      rowwise() %>%\n      filter(track_artist_name %in% top_tracks) %>%\n      group_by(\n        track_artist_name, \n        month\n      ) %>%\n      summarise(hours_listened = sum(ms_played/(1000*60)))\n    \n    ggplot(track_summary, aes(x = month, y = hours_listened, fill = track_artist_name, label = track_artist_name)) +\n      xlab(\"Date\") +\n      ylab(\"Proportion\") +\n      geom_bar(position = \"fill\", stat = \"identity\") +\n      geom_text(size = 3, position = position_fill(vjust = 0.5)) +\n      theme(legend.position = \"none\")\n  })\n}\n\nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n## Track Feature Data\n\nNext, we'll need to use Spotify's Web API to obtain track features, which requires the track ID of each track we're interested in. Fortunately, since we requested our full activity history, this data is included as a column. \n\n::: {.callout-note}\nOn the topic of Spotify's Web API, it's interesting to note that it also includes genres. However, genres are linked to artists, not tracks, which makes this feature less noteworthy compared to track features.\n:::\n\nWe can use the `httr` and `jsonlite` packages to create a function that takes a Spotify track ID and returns its track features.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_audio_features <- function(track_id) {\n  url = paste0(\"https://api.spotify.com/v1/audio-features/\", track_id)\n  response <- GET(\n    url,\n    add_headers(Authorization = paste(\"Bearer\", spotify_token))\n  )\n  data <- fromJSON(\n    content(\n      response, \n      \"text\", \n      encoding = \"UTF-8\"\n    )\n  )\n  return(data)\n}\n```\n:::\n\n\nGiven the large number of track IDs, using this function on all tracks in our dataset is a long and painful process, where we will get rate limited many times by Spotify. Conveniently, I have a local file containing all of our tracks and their associated track features, which I will load in.\n\nThe description for each feature can be found in Spotify's [documentation](https://developer.spotify.com/documentation/web-api/reference/get-audio-features){target=_blank}.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|track_name                                  |artist_name       |track_uri              | danceability| energy| key| loudness| mode| speechiness| acousticness| instrumentalness| liveness| valence|   tempo| duration_ms| time_signature|\n|:-------------------------------------------|:-----------------|:----------------------|------------:|------:|---:|--------:|----:|-----------:|------------:|----------------:|--------:|-------:|-------:|-----------:|--------------:|\n|Psychedelic Switch                          |Carly Rae Jepsen  |7zy2kNoeD72x2NEDaAsJOX |        0.681|  0.805|   4|   -6.676|    1|      0.0480|      0.00182|         1.58e-02|    0.341|   0.304| 127.907|      272035|              4|\n|Sick Feeling                                |boy pablo         |7zxLkZbUxITHabPzGN8Xgc |        0.415|  0.504|   9|  -10.003|    1|      0.0318|      0.02200|         3.80e-06|    0.363|   0.401| 165.860|      155714|              4|\n|You Get Me So High                          |The Neighbourhood |7zwn1eykZtZ5LODrf7c0tS |        0.551|  0.881|   7|   -6.099|    0|      0.0542|      0.18600|         7.91e-02|    0.152|   0.387|  88.036|      153000|              4|\n|No Different                                |Epik High         |7ztlf9mCrjoLXAYYf0LCYx |        0.732|  0.600|   1|   -6.127|    1|      0.0535|      0.03070|         8.25e-05|    0.137|   0.238| 131.912|      200362|              4|\n|Sorry                                       |The Rose          |7zmrZMinkTMJ2kZgM9Kqgp |        0.388|  0.642|  10|   -4.659|    1|      0.0337|      0.47100|         0.00e+00|    0.306|   0.402| 173.610|      215477|              4|\n|Livin It Up (with Post Malone & A$AP Rocky) |Young Thug        |7zjEyeBsaw9gV0jofJLfOM |        0.767|  0.313|   7|  -12.059|    1|      0.0798|      0.83800|         0.00e+00|    0.105|   0.765|  82.582|      210907|              4|\n\n\n:::\n:::\n\n\nWe can then remove discrete track features and scale the remaining features so that the clusters are not affected by the difference in magnitude of different features.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeature_matrix <- full_track_features %>%\n  mutate(track_artist = paste(track_name, artist_name, sep = \" - \")) %>%\n  select(\n    -track_name, \n    -artist_name\n  ) %>%\n  column_to_rownames(var = \"track_artist\") %>%\n  select(\n    -track_uri,\n    -key,\n    -mode,\n    -time_signature\n  ) %>%\n  scale()\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|                                                         | danceability|     energy|   loudness| speechiness| acousticness| instrumentalness|   liveness|    valence|      tempo| duration_ms|\n|:--------------------------------------------------------|------------:|----------:|----------:|-----------:|------------:|----------------:|----------:|----------:|----------:|-----------:|\n|Psychedelic Switch - Carly Rae Jepsen                    |    0.5034878|  1.3400006|  0.4206709|  -0.3325940|   -1.3132909|       -0.3305910|  1.3463448| -0.5950222|  0.3365591|   1.3459625|\n|Sick Feeling - boy pablo                                 |   -1.2632525| -0.0712252| -0.3296591|  -0.5474916|   -1.2506975|       -0.3915509|  1.5205894| -0.1757695|  1.6071509|  -0.7309358|\n|You Get Me So High - The Neighbourhood                   |   -0.3599567|  1.6963234|  0.5508003|  -0.2503492|   -0.7420099|       -0.0863063| -0.1505748| -0.2362802| -0.9982436|  -0.7793940|\n|No Different - Epik High                                 |    0.8422237|  0.3788667|  0.5444855|  -0.2596349|   -1.2237122|       -0.3912473| -0.2693779| -0.8802870|  0.4706386|   0.0662492|\n|Sorry - The Rose                                         |   -1.4425833|  0.5757820|  0.8755599|  -0.5222876|    0.1419900|       -0.3915657|  1.0691375| -0.1714473|  1.8666057|   0.3361258|\n|Livin It Up (with Post Malone & A$AP Rocky) - Young Thug |    1.0746895| -0.9667206| -0.7933436|   0.0892422|    1.2803337|       -0.3915657| -0.5228246|  1.3975087| -1.1808328|   0.2545290|\n\n\n:::\n:::\n\n\n# K-means\n\nNow that we have the required data, we can move on to the machine learning algorithm of interest, k-means clustering.\n\n## What is K-means?\n\nThe k-means algorithm basically goes:\n\n1. Choose $k$ random points within the domain of your factors.\n2. Create $k$ clusters by assigning each observation to its nearest point, which is now referred to as a mean.\n3. The centroid of each cluster then becomes the new mean.\n4. Repeat until convergence.\n\nThe obvious question is: how do we determine the value of $k$ for a given set of factors? One method would be to use something called a silhouette value. We can understand the silhouette value by considering a group of clustered data points, shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Chart Code\"}\nset.seed(2687)\n\nrand_data <- data.frame(\n  x = rnorm(50),\n  y = rnorm(50)\n)\n\nkm <- kmeans(rand_data, 3)\n\nfviz_cluster(\n  km,\n  data = rand_data,\n  geom = \"point\"\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nWe'll let $s_i$ be the silhouette value for point $i$ which belongs to cluster $C_I$, then\n\n$$\n\\begin{split}\ns_i&=\\frac{b_i-a_i}{\\text{max}(a_i,b_i)},\\text{ if }|C_I|>1,\\\\\ns_i&=0,\\text{ if }|C_I|=0,\n\\end{split}\n$$\n\nwhere\n\n$$\n\\begin{split}\na_i&=\\frac{1}{|C_I|-1}\\sum_{j\\in C_I,i\\neq j}\\text{d}(i,j),\\\\\nb_i&=\\text{min}\\frac{1}{|C_J|}\\sum_{j\\in C_J}\\text{d}(i,j),\\text{ where }J\\neq I.\n\\end{split}\n$$\n\nSimply put, $a_i$ is the average of some measure of distance between point $i$ and every other point in cluster $C_I$ besides itself, and $b_i$ is the minimum average of some measure of distance between $i$ and every other point in some other cluster $C_J$. The cluster $C_J$, used to determine $b_i$, is sometimes referred to as the neighboring cluster of point $i$ as it is the next closest cluster after $C_I$.\n\nThus, given the definition of $s_i$, higher values of $s_i$ indicate a better fit of a point $i$ in its cluster $C_I$.\n\nFollowing the definition of a silhouette value for a single point, the clustering performance of the entire dataset is calculated via the average silhouette value of all points.\n\nThus, we can determine the optimal number of clusters by:\n\n1. Running the k-means algorithm using $n$ clusters.\n2. Evaluating the average silhouette value.\n3. Repeat for a reasonable range of $n$.\n4. Ranking $n$ by maximum average silhouette value. \n\nConveniently, the `fviz_nbclust` function takes care of this process for us.\n\n## Feature selection\n\nThe next problem is finding the optimal features to include our model. Generally speaking, an easy way to determine the relevant features to include in a model is to use domain knowledge. However, we do not have this luxury as I know nothing about audio engineering. So, we will do it the hard way, by trying every combination of features and selecting the ones with the best performance.\n\nTo do this, we can use a function I wrote that does the following:\n\n1. Takes inputs `n`, `data`, `nstart`, `itermax`. Where `n` is is the number of factors to consider, and `data` is the feature matrix previously generated. The `nstart` and `itermax` inputs are values passed on to the `kmeans` function.\n2. Finds all combinations of `n` factors within `data`.\n3. For each combination, determine the optimal number of clusters using using average silhouette value, and fit k-means clusters.\n4. Records performance metrics and cluster plot.\n\nThe function then outputs a dataframe that contains a row for each combination of `n` factors.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Function Code\"}\nkmeans_select_features <- function(n, data, nstart, itermax) {\n  comb_n <- data %>%\n    colnames() %>%\n    combn(n, simplify = FALSE)\n  \n  old_cols <- seq(1, n)\n  new_cols <- paste0(\"factor_\", seq(1, n))\n  \n  new_cols_sym <- syms(new_cols)\n  \n  factor_combinations_n <- do.call(rbind.data.frame, comb_n) %>%\n    rename_with(~new_cols, all_of(old_cols)) %>%\n    mutate(factors = pmap(list(!!!new_cols_sym), c)) %>%\n    mutate(n_factors = n) %>%\n    select(-(!!new_cols)) %>%\n    mutate(data = map(factors,\n                      ~data %>%\n                        as.data.frame() %>%\n                        select(all_of(.x)))) %>%\n    mutate(n_clusters = map(data,\n                            ~fviz_nbclust(.x, \n                                          kmeans, \n                                          nstart = nstart, \n                                          iter.max = itermax)[[\"data\"]] %>%\n                              slice(which.max(y)) %>%\n                              select(clusters) %>%\n                              as.numeric(),\n                            .progress = paste(\"Finding optimal n_clusters:\", \n                                              n, \n                                              \"factors\")) %>%\n             as.numeric()) %>% \n    mutate(km = map2(data,\n                     n_clusters,\n                     ~kmeans(.x, \n                             .y, \n                             nstart = nstart, \n                             iter.max = itermax,\n                             algorithm = \"MacQueen\"),\n                     .progress = paste(\"Calculating kmeans:\", \n                                       n, \n                                       \"factors\"))) %>%\n    mutate(total_withinss = map(km,\n                                ~.x$tot.withinss) %>%\n             as.numeric(),\n           bsstssRatio = map(km,\n                             ~.x$betweenss/.x$totss) %>%\n             as.numeric()) %>%\n    mutate(km_plot = map2(km,\n                          data,\n                          ~fviz_cluster(.x,\n                                        data = .y,\n                                        geom = \"point\",\n                                        ellipse.type = \"convex\"))) %>%\n    arrange(desc(bsstssRatio))  \n  \n  return(factor_combinations_n)\n}\n```\n:::\n\n\nThe function can then be used on all values of `n`, from 2 to the total number of factors. As this process is computationally intensive, and most R packages do not support multi-threading, we can use the `foreach` and `doParallel` packages to write a multi-threaded for loop which utilises all cores of the local computer. If we paid for all our CPU cores, we might as well use them right?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2687)\n\ncl <- makeCluster(detectCores())\nregisterDoParallel(cl)\n\nkmeans_nfact <- foreach(n = seq(2, ncol(feature_matrix)),\n                        .packages = c(\n                          \"tidyverse\",\n                          \"cluster\",\n                          \"factoextra\",\n                          \"rlang\"\n                        ),\n                        .combine = bind_rows) %dopar% {\n                          kmeans_select_features(n, feature_matrix, 25, 1000)\n                        } %>% \n  arrange(desc(bsstssRatio))\n\nstopCluster(cl)\n```\n:::\n\n\nThis results in a dataframe containing all possible combinations of factors for our dataset, and their k-means clustering results and performance, based on a value of $k$ determined by average silhouette value.\n\n# Results\n\nWe can now visualise the top 20 k-means results from our previous calculation using a shiny application. It's interesting that the highest performing clustering results only contain 2-3 factors.\n\n\n```{=html}\n<iframe src=\"https://harryz.shinyapps.io/spotify_clustering_dashboard/\" style=\"border: none; width: 100%; height: 900px\"></iframe>\n```\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"app.R\"}\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(here)\nlibrary(foreach)\nlibrary(english)\n\n# Load Data\n\nload(\"data/R_data/kmeans_nfact.RData\")\n\nfiles <- list.files(\n  paste0(here(), \"/data/full_history_data\"), \n  pattern = \"*.json\", \n  full.names = TRUE\n)\n\nfull_streaming_history <- foreach(\n  file = files, \n  .packages = c(\"jsonlite\"),\n  .combine = rbind\n) %do% {\n  fromJSON(file, flatten = TRUE)\n} %>%\n  rename(\n    track_name = \"master_metadata_track_name\",\n    artist_name = \"master_metadata_album_artist_name\"\n  ) %>%\n  mutate(\n    track_uri = gsub(\"spotify:track:\", \"\", spotify_track_uri),\n    month = ts %>%\n      substring(1, 7) %>%\n      paste0(\"-01\") %>%\n      ymd()\n  ) %>%\n  select(-spotify_track_uri) %>%\n  filter(month >= ymd(\"2019-04-01\"))\n\nmin_date <- full_streaming_history %>%\n  pull(month) %>%\n  min()\n\nmax_date <- full_streaming_history %>%\n  pull(month) %>%\n  max()\n\n# UI\n\nui <- fluidPage(\n  titlePanel(\"Spotify Clustering\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        \"index\", \n        \"Clustering Performance Rank\", \n        choices = seq(1, nrow(kmeans_nfact_save))\n      ),\n      sliderInput(\n        \"dates\",\n        \"Streaming History Date Range\",\n        min = min_date,\n        max = max_date,\n        value = c(max_date %m-% months(6), max_date)\n      )\n    ),\n    mainPanel(\n      tabsetPanel(\n        type = \"tabs\",\n        tabPanel(\n          \"Cluster Plot\",\n          h1(textOutput(\"cluster_title\")),\n          textOutput(\"cluster_description\"),\n          h2(\"Cluster Centres\"),\n          tableOutput(\"cluster_table\"),\n          h2(\"Cluster Plot\"),\n          plotOutput(\"cluster_plot\")\n        ),\n        tabPanel(\n          \"Cluster History Plot\", \n          h1(\"Cluster History Plot\"),\n          p(\"This plot shows the proportion of hours listened for each cluster.\"),\n          plotOutput(\"cluster_history_plot\")\n        ),\n        tabPanel(\n          \"Track Clusters\", \n          h1(\"Track Clusters\"),\n          textOutput(\"track_clusters_desc\"),\n          dataTableOutput(\"track_clusters\")\n        )\n      )\n    )\n  )\n)\n\n# SERVER\n\nserver <- function(input, output) {\n  output$cluster_title <- renderText({\n    rank <- input$index\n    \n    paste0(\n      \"K-means Cluster: Rank \",\n      rank\n    )\n  })\n  \n  output$cluster_description <- renderText({\n    total_withinss <- kmeans_nfact_save %>%\n      slice(as.numeric(input$index)) %>%\n      pull(total_withinss) %>%\n      round(digits = 2)\n    \n    bsstssRatio <- kmeans_nfact_save %>%\n      slice(as.numeric(input$index)) %>%\n      pull(bsstssRatio) %>%\n      round(digits = 2)\n    \n    index_ordinal <- input$index %>%\n      as.numeric() %>%\n      ordinal()\n    \n    paste0(\n      \"The graph below shows the k-means cluster with the \", \n      index_ordinal,\n      \" highest BSS/TSS ratio of \",\n      bsstssRatio,\n      \" and a total within sum of squares of \",\n      total_withinss,\n      \".\"\n    )\n  })\n  \n  output$track_clusters_desc <- renderText({\n    start_date <- input$dates[1]\n    end_date <- input$dates[2]\n    \n    paste0(\n      \"This table shows the cluster of all tracks listened to from \",\n      start_date,\n      \" to \",\n      end_date,\n      \".\"\n    )\n  })\n  \n  output$track_clusters <- renderDataTable({\n    kmeans_nfact_save %>%\n      slice(as.numeric(input$index)) %>%\n      pull(km) %>%\n      pluck(1) %>%\n      pluck(\"cluster\") %>%\n      as.data.frame() %>%\n      rownames_to_column(\"track_artist\") %>%\n      rename(cluster = 2) %>% \n      mutate(cluster = paste0(\"Cluster \", cluster)) %>%\n      left_join(\n        full_streaming_history %>%\n          filter(\n            month %>%\n              between(input$dates[1], input$dates[2])\n          ) %>%\n          select(\n            track_name,\n            artist_name\n          ) %>%\n          na.omit() %>%\n          distinct() %>%\n          mutate(\n            track_artist = paste(\n              track_name,\n              artist_name,\n              sep = \" - \"\n            )\n          ),\n        .,\n        by = \"track_artist\"\n      ) %>%\n      select(\n        cluster,\n        artist_name,\n        track_name\n      ) %>%\n      arrange(\n        cluster,\n        artist_name,\n        track_name\n      ) %>%\n      rename(\n        Cluster = \"cluster\",\n        `Artist Name` = \"artist_name\",\n        `Track Name` = \"track_name\"\n      )\n  })\n  \n  output$cluster_plot <- renderPlot({\n    kmeans_nfact_save %>%\n      slice(as.numeric(input$index)) %>%\n      pull(km_plot)\n  })\n  \n  output$cluster_table <- renderTable({\n    kmeans_nfact_save %>%\n      slice(as.numeric(input$index)) %>%\n      pull(km) %>%\n      pluck(1) %>%\n      pluck(\"centers\") %>%\n      as.data.frame() %>%\n      rownames_to_column(\"cluster\") %>%\n      mutate(cluster = paste0(\"Cluster \", cluster))\n  })\n  \n  output$cluster_history_plot <- renderPlot({\n    track_clusters <- kmeans_nfact_save %>%\n      slice(as.numeric(input$index)) %>%\n      pull(km) %>%\n      pluck(1) %>%\n      pluck(\"cluster\") %>%\n      as.data.frame() %>%\n      rownames_to_column(\"track_artist\") %>%\n      rename(cluster = 2) %>% \n      mutate(cluster = paste0(\"Cluster \", cluster)) %>%\n      left_join(\n        full_streaming_history %>%\n          select(\n            track_name,\n            artist_name\n          ) %>%\n          na.omit() %>%\n          distinct() %>%\n          mutate(\n            track_artist = paste(\n              track_name,\n              artist_name,\n              sep = \" - \"\n            )\n          ),\n        .,\n        by = \"track_artist\"\n      ) %>%\n      select(-track_artist) %>%\n      arrange(\n        artist_name,\n        track_name\n      )\n    \n    cluster_summary <- full_streaming_history %>%\n      select(\n        month,\n        track_name,\n        artist_name,\n        ms_played\n      ) %>%\n      na.omit() %>%\n      filter(\n        month %>%\n          between(input$dates[1], input$dates[2])\n      ) %>%\n      left_join(\n        track_clusters, \n        by = c(\"track_name\", \"artist_name\")\n      ) %>%\n      group_by(\n        month, \n        cluster\n      ) %>%\n      summarise(hours_listened = sum(ms_played/(1000*60)))\n    \n    ggplot(cluster_summary, aes(x = month, y = hours_listened, fill = cluster, label = cluster)) +\n      xlab(\"Date\") +\n      ylab(\"Proportion\") +\n      geom_bar(position = \"fill\", stat = \"identity\")\n  })\n}\n\nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n## Cluster Playlists\n\nJust for fun, and to see if our subjective interpretation of grouping songs together aligns at all with k-means and Spotify's API, we can calculate the top 5 tracks by hours listened for each cluster in the highest performing k-means result.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Top 5 Tracks Code\"}\ncluster_top_tracks <- kmeans_nfact_save %>%\n  slice(1) %>%\n  pull(km) %>%\n  pluck(1) %>%\n  pluck(\"cluster\") %>%\n  as.data.frame() %>%\n  rownames_to_column(\"track_artist\") %>%\n  rename(cluster = 2) %>% \n  mutate(cluster = paste0(\"Cluster \", cluster)) %>%\n  left_join(\n    full_streaming_history %>%\n      select(\n        track_name,\n        artist_name,\n        ms_played\n      ) %>%\n      na.omit() %>%\n      group_by(\n        track_name,\n        artist_name\n      ) %>%\n      summarise(\n        hours_listened = sum(ms_played/(1000*60))\n      ) %>%\n      mutate(\n        track_artist = paste(\n          track_name,\n          artist_name,\n          sep = \" - \"\n        )\n      ),\n      .,\n      by = \"track_artist\"\n    ) %>%\n  select(-track_artist) %>%\n  group_by(cluster) %>%\n  slice_max(hours_listened, n = 5) %>%\n  ungroup() %>%\n  select(\n    cluster,\n    track_name,\n    artist_name\n  )\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|cluster   |track_name                                                     |artist_name          |\n|:---------|:--------------------------------------------------------------|:--------------------|\n|Cluster 1 |i <3 u                                                         |boy pablo            |\n|Cluster 1 |Apocalypse                                                     |Cigarettes After Sex |\n|Cluster 1 |Nothing                                                        |Bruno Major          |\n|Cluster 1 |Sunsetz                                                        |Cigarettes After Sex |\n|Cluster 1 |Wonder                                                         |ADOY                 |\n|Cluster 2 |May I Ask                                                      |Luke Chiang          |\n|Cluster 2 |drunk                                                          |keshi                |\n|Cluster 2 |is your bedroom ceiling bored? (feat. Rxseboy) - Fudasca Remix |Sody                 |\n|Cluster 2 |drivers license                                                |Olivia Rodrigo       |\n|Cluster 2 |Location Unknown ◐                                             |HONNE                |\n|Cluster 3 |change ur mind                                                 |Sarcastic Sounds     |\n|Cluster 3 |stay4ever (feat. Mounika.)                                     |Powfu                |\n|Cluster 3 |affection                                                      |BETWEEN FRIENDS      |\n|Cluster 3 |boyfriend (with Social House)                                  |Ariana Grande        |\n|Cluster 3 |not ur friend                                                  |Jeremy Zucker        |\n\n\n:::\n:::\n\n\nThen, we can make some playlists:\n\n##### Cluster 1 Playlist\n\n\n```{=html}\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/playlist/0FWZHIrHFCy4fdcmdmuez1?utm_source=generator\" width=\"100%\" height=\"152\" frameBorder=\"0\" allowfullscreen=\"\" allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\"></iframe>\n```\n\n\n##### Cluster 2 Playlist\n\n\n```{=html}\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/playlist/2EO24dIxXTDizr6FbXamqY?utm_source=generator\" width=\"100%\" height=\"152\" frameBorder=\"0\" allowfullscreen=\"\" allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\"></iframe>\n```\n\n\n##### Cluster 3 Playlist\n\n\n```{=html}\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/playlist/5kLF4CIVyNg7A9PADnV23E?utm_source=generator\" width=\"100%\" height=\"152\" frameBorder=\"0\" allowfullscreen=\"\" allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\"></iframe>\n```",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}